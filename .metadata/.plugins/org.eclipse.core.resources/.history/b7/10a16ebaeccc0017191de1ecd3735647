package edu.demon.Object6;

import java.text.AttributedString;

import sun.management.resources.agent;
interface A {
	public static final int AAA = 0;
	public abstract void ATest();
}
interface B {
	public static final int BBB = 0;
	public abstract void BTest();
}
interface C extends A,B {
	public static final int C = 0;
	public abstract void CTest();
}

class Father {
	int age = 40;
	void speak() {
		System.out.println("I am father");
	}
	static void sing() {
		System.out.println("Father sing");
	}
	void shout() {
		System.out.println("Father angry");
		speak();
	}
}
class Son extends Father {
	int age = 20;
	void speak() {
		System.out.println("I am son");
	}
	static void sing() {
		System.out.println("Son sing");
	}
	void shout(String str) {
		System.out.println("Father angry" + str);
	}
}
public class RuntimePolymorphic {

	public static void main(String[] args) {
		Father father = new Son();
		father.speak();
		// 父类中属性只能被隐藏，而不能被覆盖；
		// 而对于方法来说，方法隐藏只有一种形式，就是父类和子类存在相同的静态方法。
		father.sing();
		System.out.println("I am " + father.age + " years old!");
		// 首先，利用编译时多态，执行父类中的shout()方法，然后仍然调用子类的speak()
		father.shout();
	}
}
